/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Timestamp.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Timestamp
 #	author : miyako
 #	2020/03/10
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Timestamp.h"

#pragma mark -

void OnStartup() {
    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \
                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                       
			// --- Timestamp
            
			case 1 :
				Create_timestamp_query(params);
				break;
			case 2 :
				Verify_timestamp_request(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void CC_EVP(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md) {
    
    unsigned int mdlen = mlen;
    EVP_MD_CTX* c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinal(c, md, &mdlen);
    EVP_MD_CTX_free(c);
}

void *app_malloc(int sz, const char *what) {
    
    void *vp = OPENSSL_malloc(sz);
    
    return vp;
}

ASN1_INTEGER *create_nonce(int bits) {
    
    unsigned char buf[20];
    ASN1_INTEGER *nonce = NULL;
    int len = (bits - 1) / 8 + 1;
    int i;

    if (len > (int)sizeof(buf))
        goto err;
    if (RAND_bytes(buf, len) <= 0)
        goto err;

    /* Find the first non-zero byte and creating ASN1_INTEGER object. */
    for (i = 0; i < len && !buf[i]; ++i)
        continue;
    if ((nonce = ASN1_INTEGER_new()) == NULL)
        goto err;
    OPENSSL_free(nonce->data);
    nonce->length = len - i;
    nonce->data = (unsigned char *)app_malloc(nonce->length + 1, "nonce buffer");
    memcpy(nonce->data, buf + i, nonce->length);
    return nonce;

 err:

    ASN1_INTEGER_free(nonce);
    return NULL;
}

ASN1_OBJECT *txt2obj(const char *oid) {
    
    ASN1_OBJECT *oid_obj = OBJ_txt2obj(oid, 0);

    return oid_obj;
}

void CC_SHA(const void *data, uint32_t len, const EVP_MD *evp, unsigned int hashlen, unsigned char *md) {
    
    CC_EVP(evp, hashlen, data, len, md);
}

void CC_HASH(unsigned int hashlen,
             void (*CC)(const void *data,
                        uint32_t len,
                        const EVP_MD *evp,
                        unsigned int hashlen,
                        unsigned char *md),
             const EVP_MD *evp,
             C_BLOB &Param1,
             C_BLOB &returnValue) {

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    
    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), evp, hashlen, buf);

    returnValue.setBytes((const uint8_t *)buf, hashlen);
    
    free(buf);
}

#pragma mark -

void Create_timestamp_query(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);

    /*
     defaults:
     format: asn1
     hash: sha512
     cert: 1
     no_nonce: 1
     policy: NULL
     */
    
    timestamp_query_hash_type_t hash_type = timestamp_query_hash_type_sha512;
    timestamp_export_format_t export_format = timestamp_export_format_asn1;
    
    int cert = 1;
    int no_nonce = 1;
    char *policy = NULL;
    
    CUTF8String policyOid;
    
    if(options) {
		unsigned int i = ob_get_n(options, L"format");
        export_format = (timestamp_export_format_t)i;
        
        if(ob_is_defined(options, L"no_nonce")) {
            no_nonce = ob_get_b(options, L"no_nonce");
        }
        
        if(ob_is_defined(options, L"cert")) {
            cert = ob_get_b(options, L"cert");
        }
        
        if(ob_is_defined(options, L"hash")) {
			unsigned int i = ob_get_n(options, L"hash");
            hash_type = (timestamp_query_hash_type_t)i;
        }
        
        if(ob_is_defined(options, L"policy")) {
            ob_get_s(options, L"policy", &policyOid);
            policy = (char *)policyOid.c_str();
        }
 
    }
    
    C_BLOB returnValue;
    
    BIO *bio_Param1 = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());
    
    if(bio_Param1){
        
        const EVP_MD *md = NULL;
        
        switch (hash_type) {
            case timestamp_query_hash_type_sha1:
                md = EVP_sha1();
                CC_HASH(20, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha224:
                md = EVP_sha224();
                CC_HASH(28, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha256:
                md = EVP_sha256();
                CC_HASH(32, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha384:
                md = EVP_sha384();
                CC_HASH(48, CC_SHA, md, Param1, returnValue);
                break;
                
            default:
                md = EVP_sha512();
                CC_HASH(64, CC_SHA, md, Param1, returnValue);
                break;
        }
        
        int ret = 0;
        
        ASN1_INTEGER *nonce_asn1 = NULL;
        X509_ALGOR *algo = NULL;
        TS_MSG_IMPRINT *msg_imprint = NULL;
        TS_REQ *ts_req = NULL;
        ASN1_OBJECT *policy_obj = NULL;
        
        if ((ts_req = TS_REQ_new()) == NULL)
            goto err;
        
        if (!TS_REQ_set_version(ts_req, 1))
            goto err;
        
        if ((msg_imprint = TS_MSG_IMPRINT_new()) == NULL)
            goto err;
        
        if ((algo = X509_ALGOR_new()) == NULL)
            goto err;
        
        if ((algo->algorithm = OBJ_nid2obj(EVP_MD_type(md))) == NULL)
            goto err;
        
        if ((algo->parameter = ASN1_TYPE_new()) == NULL)
            goto err;
        
        algo->parameter->type = V_ASN1_NULL;
        
        if (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo))
            goto err;
        
        if (!TS_MSG_IMPRINT_set_msg(msg_imprint,
                                    (unsigned char *)returnValue.getBytesPtr(),
                                    (int)returnValue.getBytesLength()))
            goto err;
        
        if (!TS_REQ_set_msg_imprint(ts_req, msg_imprint))
            goto err;
                
        if (policy && (policy_obj = txt2obj((const char *)policy)) == NULL)
            goto err;
        
        if (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj))
            goto err;
        
        if (!no_nonce && (nonce_asn1 = create_nonce(NONCE_LENGTH)) == NULL)
            goto err;
        
        if (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1))
            goto err;
        
        if (!TS_REQ_set_cert_req(ts_req, cert))
            goto err;
        
        ret = 1;
        
        err:
        
        if (!ret) {
            TS_REQ_free(ts_req);
            ts_req = NULL;
        }
        
        TS_MSG_IMPRINT_free(msg_imprint);
        X509_ALGOR_free(algo);
        ASN1_OBJECT_free(policy_obj);
        ASN1_INTEGER_free(nonce_asn1);
        
        TS_REQ *query = ts_req;
        
        if (query) {
            
            BIO *bio_returnValue = BIO_new(BIO_s_mem());
            
            if(bio_returnValue) {
                int exported = 0;
                switch (export_format) {
                    case timestamp_export_format_asn1:
                        if(i2d_TS_REQ_bio(bio_returnValue, query)){
                            exported = 1;
                        }
                        break;
                    default:
                        if(TS_REQ_print_bio(bio_returnValue, query)){
                            exported = 1;
                        }
                        break;
                }
                if(exported) {
                    char *buf = NULL;
                    int len = (int)BIO_get_mem_data(bio_returnValue, &buf);
                    
                    if(len){
                        returnValue.setBytes((const uint8_t *)buf, len);
                        returnValue.setReturn(pResult);
                    }
                    
                }
                BIO_free(bio_returnValue);
            }
            TS_REQ_free(query);
        }
        BIO_free(bio_Param1);
    }

}

#pragma mark -

int verify_cb(int ok, X509_STORE_CTX *ctx) {
    
    return ok;
}

/* Reads a PKCS7 token and adds default 'granted' status info to it. */
TS_RESP *read_PKCS7(BIO *in_bio) {
    
    int ret = 0;
    PKCS7 *token = NULL;
    TS_TST_INFO *tst_info = NULL;
    TS_RESP *resp = NULL;
    TS_STATUS_INFO *si = NULL;

    if ((token = d2i_PKCS7_bio(in_bio, NULL)) == NULL)
        goto end;
    if ((tst_info = PKCS7_to_TS_TST_INFO(token)) == NULL)
        goto end;
    if ((resp = TS_RESP_new()) == NULL)
        goto end;
    if ((si = TS_STATUS_INFO_new()) == NULL)
        goto end;
    if (!TS_STATUS_INFO_set_status(si, TS_STATUS_GRANTED))
        goto end;
    if (!TS_RESP_set_status_info(resp, si))
        goto end;
    TS_RESP_set_tst_info(resp, token, tst_info);
    token = NULL;               /* Ownership is lost. */
    tst_info = NULL;            /* Ownership is lost. */
    ret = 1;

 end:
    PKCS7_free(token);
    TS_TST_INFO_free(tst_info);
    if (!ret) {
        TS_RESP_free(resp);
        resp = NULL;
    }
    TS_STATUS_INFO_free(si);
    return resp;
}

X509_STORE *create_cert_store(const char *CApath, const char *CAfile,
                                     const char *CAstore, X509_VERIFY_PARAM *vpm) {
    
    X509_STORE *cert_ctx = NULL;
    X509_LOOKUP *lookup = NULL;

    cert_ctx = X509_STORE_new();
    X509_STORE_set_verify_cb(cert_ctx, verify_cb);
    
    if (CApath != NULL) {
        lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());
        if (lookup == NULL) {
            
            goto err;
        }
        if (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM)) {
            
        }
        
        if (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_ASN1 /* DER */)) {
            
        }
    }

    if (CAfile != NULL) {
        lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());
        if (lookup == NULL) {

            goto err;
        }
        if (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM)) {
            
            if (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_ASN1 /* DER */)) {
                
                goto err;
                
            }
        }
    }

    /*
     if (CAstore != NULL) {
         lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_store());
         if (lookup == NULL) {

             goto err;
         }
         if (!X509_LOOKUP_load_store(lookup, CAstore)) {

             goto err;
         }
     }
     */

    if (vpm != NULL)
        X509_STORE_set1_param(cert_ctx, vpm);

    return cert_ctx;

 err:
    X509_STORE_free(cert_ctx);
    return NULL;
}

TS_VERIFY_CTX *create_verify_ctx(TS_REQ *query,
                                 const char *CApath,
                                 const char *CAfile,
                                 const char *CAstore,
                                 const char *untrusted,
                                 X509_VERIFY_PARAM *vpm) {
    
    TS_VERIFY_CTX *ctx = NULL;
    
    int ret = 0;
    int f = 0;
    
    if (query) {
        if ((ctx = TS_REQ_to_TS_VERIFY_CTX(query, NULL)) == NULL)
            goto err;
    } else {
        return NULL;
    }
    
    /* Add the signature verification flag and arguments. */
    TS_VERIFY_CTX_add_flags(ctx, f | TS_VFY_SIGNATURE);
    
    /* Initialising the X509_STORE object. */
    if (TS_VERIFY_CTX_set_store(ctx,
                                create_cert_store(CApath, CAfile, CAstore, vpm))
        == NULL)
        goto err;
    
    /* Loading untrusted certificates. */
    if (untrusted
        && TS_VERIFY_CTS_set_certs(ctx, TS_CONF_load_certs(untrusted)) == NULL)
        goto err;
    
    ret = 1;
    
err:
    if (!ret) {
        TS_VERIFY_CTX_free(ctx);
        ctx = NULL;
    }

    return ctx;
}

bool ob_get_posix_path(PA_ObjectRef options, const wchar_t *key, CUTF8String *value) {
    
    bool status = ob_get_s(options, key, value);
    
    if(status) {
#if VERSIONMAC
        /* hfs to posix */
        C_TEXT t;
        t.setUTF8String(value);
        t.copyPath(value);
#endif
    }
    
    return status;
}

#pragma mark -

#if USE_STATIC_OPENSSL_FONCTION_FOR_TRACE

#include <openssl/asn1.h>

struct TS_resp_st {
    TS_STATUS_INFO *status_info;
    PKCS7 *token;
    TS_TST_INFO *tst_info;
};

struct TS_status_info_st {
    ASN1_INTEGER *status;
    STACK_OF(ASN1_UTF8STRING) *text;
    ASN1_BIT_STRING *failure_info;
};

#define TS_STATUS_BUF_SIZE      256

static const char *ts_status_text[] = {
    "granted",
    "grantedWithMods",
    "rejection",
    "waiting",
    "revocationWarning",
    "revocationNotification"
};

# define OSSL_NELEM(x)    (sizeof(x)/sizeof((x)[0]))

# define ossl_assert(x) ((x) != 0)

char *sk_ASN1_UTF8STRING2text(STACK_OF(ASN1_UTF8STRING) *text, const char *sep,
                              size_t max_len /* excluding NUL terminator */)
{
    int i;
    ASN1_UTF8STRING *current;
    size_t length = 0, sep_len;
    char *result = NULL;
    char *p;

    if (!ossl_assert(sep != NULL))
        return NULL;
    sep_len = strlen(sep);

    for (i = 0; i < sk_ASN1_UTF8STRING_num(text); ++i) {
        current = sk_ASN1_UTF8STRING_value(text, i);
        if (i > 0)
            length += sep_len;
        length += ASN1_STRING_length(current);
        if (length > max_len)
            return NULL;
    }
    if ((result = (char *)OPENSSL_malloc(length + 1)) == NULL)
        return NULL;

    for (i = 0, p = result; i < sk_ASN1_UTF8STRING_num(text); ++i) {
        current = sk_ASN1_UTF8STRING_value(text, i);
        length = ASN1_STRING_length(current);
        if (i > 0 && sep_len > 0) {
            strncpy(p, sep, sep_len + 1);
            p += sep_len;
        }
        strncpy(p, (const char *)ASN1_STRING_get0_data(current), length);
        p += length;
    }
    *p = '\0';

    return result;
}

static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text)
{
    return sk_ASN1_UTF8STRING2text(text, "/", TS_MAX_STATUS_LENGTH);
}

static struct {
    int code;
    const char *text;
} ts_failure_info[] = {
    {TS_INFO_BAD_ALG, "badAlg"},
    {TS_INFO_BAD_REQUEST, "badRequest"},
    {TS_INFO_BAD_DATA_FORMAT, "badDataFormat"},
    {TS_INFO_TIME_NOT_AVAILABLE, "timeNotAvailable"},
    {TS_INFO_UNACCEPTED_POLICY, "unacceptedPolicy"},
    {TS_INFO_UNACCEPTED_EXTENSION, "unacceptedExtension"},
    {TS_INFO_ADD_INFO_NOT_AVAILABLE, "addInfoNotAvailable"},
    {TS_INFO_SYSTEM_FAILURE, "systemFailure"}
};

static int ts_check_status_info(TS_RESP *response)
{
    TS_STATUS_INFO *info = response->status_info;
    long status = ASN1_INTEGER_get(info->status);
    const char *status_text = NULL;
    char *embedded_status_text = NULL;
    char failure_text[TS_STATUS_BUF_SIZE] = "";

    if (status == 0 || status == 1)
        return 1;

    /* There was an error, get the description in status_text. */
    if (0 <= status && status < (long) OSSL_NELEM(ts_status_text))
        status_text = ts_status_text[status];
    else
        status_text = "unknown code";

    if (sk_ASN1_UTF8STRING_num(info->text) > 0
        && (embedded_status_text = ts_get_status_text(info->text)) == NULL)
        return 0;

    /* Fill in failure_text with the failure information. */
    if (info->failure_info) {
        int i;
        int first = 1;
        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        ts_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, ",");
                else
                    first = 0;
                strcat(failure_text, ts_failure_info[i].text);
            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, "unspecified");

    TSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);
    ERR_add_error_data(6,
                       "status code: ", status_text,
                       ", status text: ", embedded_status_text ?
                       embedded_status_text : "unspecified",
                       ", failure codes: ", failure_text);
    OPENSSL_free(embedded_status_text);

    return 0;
}

struct TS_tst_info_st {
    ASN1_INTEGER *version;
    ASN1_OBJECT *policy_id;
    TS_MSG_IMPRINT *msg_imprint;
    ASN1_INTEGER *serial;
    ASN1_GENERALIZEDTIME *time;
    TS_ACCURACY *accuracy;
    ASN1_BOOLEAN ordering;
    ASN1_INTEGER *nonce;
    GENERAL_NAME *tsa;
    STACK_OF(X509_EXTENSION) *extensions;
};

struct TS_verify_ctx {
    /* Set this to the union of TS_VFY_... flags you want to carry out. */
    unsigned flags;
    /* Must be set only with TS_VFY_SIGNATURE. certs is optional. */
    X509_STORE *store;
    STACK_OF(X509) *certs;
    /* Must be set only with TS_VFY_POLICY. */
    ASN1_OBJECT *policy;
    /*
     * Must be set only with TS_VFY_IMPRINT. If md_alg is NULL, the
     * algorithm from the response is used.
     */
    X509_ALGOR *md_alg;
    unsigned char *imprint;
    unsigned imprint_len;
    /* Must be set only with TS_VFY_DATA. */
    BIO *data;
    /* Must be set only with TS_VFY_TSA_NAME. */
    ASN1_INTEGER *nonce;
    /* Must be set only with TS_VFY_TSA_NAME. */
    GENERAL_NAME *tsa_name;
};

struct TS_msg_imprint_st {
    X509_ALGOR *hash_algo;
    ASN1_OCTET_STRING *hashed_msg;
};

static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
                              X509_ALGOR **md_alg,
                              unsigned char **imprint, unsigned *imprint_len)
{
    TS_MSG_IMPRINT *msg_imprint = tst_info->msg_imprint;
    X509_ALGOR *md_alg_resp = msg_imprint->hash_algo;
    const EVP_MD *md;
    EVP_MD_CTX *md_ctx = NULL;
    unsigned char buffer[4096];
    int length;

    *md_alg = NULL;
    *imprint = NULL;

    if ((*md_alg = X509_ALGOR_dup(md_alg_resp)) == NULL)
        goto err;
    if ((md = EVP_get_digestbyobj((*md_alg)->algorithm)) == NULL) {
        TSerr(TS_F_TS_COMPUTE_IMPRINT, TS_R_UNSUPPORTED_MD_ALGORITHM);
        goto err;
    }
    length = EVP_MD_size(md);
    if (length < 0)
        goto err;
    *imprint_len = length;
    if ((*imprint = (unsigned char *)OPENSSL_malloc(*imprint_len)) == NULL) {
        TSerr(TS_F_TS_COMPUTE_IMPRINT, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL) {
        TSerr(TS_F_TS_COMPUTE_IMPRINT, ERR_R_MALLOC_FAILURE);
        goto err;
    }
    if (!EVP_DigestInit(md_ctx, md))
        goto err;
    while ((length = BIO_read(data, buffer, sizeof(buffer))) > 0) {
        if (!EVP_DigestUpdate(md_ctx, buffer, length))
            goto err;
    }
    if (!EVP_DigestFinal(md_ctx, *imprint, NULL))
        goto err;
    EVP_MD_CTX_free(md_ctx);

    return 1;
 err:
    EVP_MD_CTX_free(md_ctx);
    X509_ALGOR_free(*md_alg);
    OPENSSL_free(*imprint);
    *imprint_len = 0;
    *imprint = 0;
    return 0;
}

static int ts_check_policy(const ASN1_OBJECT *req_oid,
                           const TS_TST_INFO *tst_info)
{
    const ASN1_OBJECT *resp_oid = tst_info->policy_id;

    if (OBJ_cmp(req_oid, resp_oid) != 0) {
        TSerr(TS_F_TS_CHECK_POLICY, TS_R_POLICY_MISMATCH);
        return 0;
    }

    return 1;
}

static int ts_check_imprints(X509_ALGOR *algor_a,
                             const unsigned char *imprint_a, unsigned len_a,
                             TS_TST_INFO *tst_info)
{
    TS_MSG_IMPRINT *b = tst_info->msg_imprint;
    X509_ALGOR *algor_b = b->hash_algo;
    int ret = 0;

    if (algor_a) {
        if (OBJ_cmp(algor_a->algorithm, algor_b->algorithm))
            goto err;

        /* The parameter must be NULL in both. */
        if ((algor_a->parameter
             && ASN1_TYPE_get(algor_a->parameter) != V_ASN1_NULL)
            || (algor_b->parameter
                && ASN1_TYPE_get(algor_b->parameter) != V_ASN1_NULL))
            goto err;
    }

    ret = len_a == (unsigned)ASN1_STRING_length(b->hashed_msg) &&
        memcmp(imprint_a, ASN1_STRING_get0_data(b->hashed_msg), len_a) == 0;
 err:
    if (!ret)
        TSerr(TS_F_TS_CHECK_IMPRINTS, TS_R_MESSAGE_IMPRINT_MISMATCH);
    return ret;
}

static int ts_check_nonces(const ASN1_INTEGER *a, TS_TST_INFO *tst_info)
{
    const ASN1_INTEGER *b = tst_info->nonce;

    if (!b) {
        TSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_NOT_RETURNED);
        return 0;
    }

    /* No error if a nonce is returned without being requested. */
    if (ASN1_INTEGER_cmp(a, b) != 0) {
        TSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_MISMATCH);
        return 0;
    }

    return 1;
}

static int ts_find_name(STACK_OF(GENERAL_NAME) *gen_names, GENERAL_NAME *name)
{
    int i, found;
    for (i = 0, found = 0; !found && i < sk_GENERAL_NAME_num(gen_names); ++i) {
        GENERAL_NAME *current = sk_GENERAL_NAME_value(gen_names, i);
        found = GENERAL_NAME_cmp(current, name) == 0;
    }
    return found ? i - 1 : -1;
}

static int ts_check_signer_name(GENERAL_NAME *tsa_name, X509 *signer)
{
    STACK_OF(GENERAL_NAME) *gen_names = NULL;
    int idx = -1;
    int found = 0;

    if (tsa_name->type == GEN_DIRNAME
        && X509_name_cmp(tsa_name->d.dirn, X509_get_subject_name(signer)) == 0)
        return 1;
    gen_names = (STACK_OF(GENERAL_NAME)*)X509_get_ext_d2i(signer, NID_subject_alt_name, NULL, &idx);
    while (gen_names != NULL) {
        found = ts_find_name(gen_names, tsa_name) >= 0;
        if (found)
            break;
        /*
         * Get the next subject alternative name, although there should be no
         * more than one.
         */
        GENERAL_NAMES_free(gen_names);
        gen_names = (STACK_OF(GENERAL_NAME)*)X509_get_ext_d2i(signer, NID_subject_alt_name, NULL, &idx);
    }
    GENERAL_NAMES_free(gen_names);

    return found;
}

static int int_ts_RESP_verify_token(TS_VERIFY_CTX *ctx,
                                    PKCS7 *token, TS_TST_INFO *tst_info)
{
    X509 *signer = NULL;
    GENERAL_NAME *tsa_name = tst_info->tsa;
    X509_ALGOR *md_alg = NULL;
    unsigned char *imprint = NULL;
    unsigned imprint_len = 0;
    int ret = 0;
    int flags = ctx->flags;

    /* Some options require us to also check the signature */
    if (((flags & TS_VFY_SIGNER) && tsa_name != NULL)
            || (flags & TS_VFY_TSA_NAME)) {
        flags |= TS_VFY_SIGNATURE;
    }

    if ((flags & TS_VFY_SIGNATURE)
        && !TS_RESP_verify_signature(token, ctx->certs, ctx->store, &signer))
        goto err;
    if ((flags & TS_VFY_VERSION)
        && TS_TST_INFO_get_version(tst_info) != 1) {
        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_UNSUPPORTED_VERSION);
        goto err;
    }
    if ((flags & TS_VFY_POLICY)
        && !ts_check_policy(ctx->policy, tst_info))
        goto err;
    if ((flags & TS_VFY_IMPRINT)
        && !ts_check_imprints(ctx->md_alg, ctx->imprint, ctx->imprint_len,
                              tst_info))
        goto err;
    if ((flags & TS_VFY_DATA)
        && (!ts_compute_imprint(ctx->data, tst_info,
                                &md_alg, &imprint, &imprint_len)
            || !ts_check_imprints(md_alg, imprint, imprint_len, tst_info)))
        goto err;
    if ((flags & TS_VFY_NONCE)
        && !ts_check_nonces(ctx->nonce, tst_info))
        goto err;
    if ((flags & TS_VFY_SIGNER)
        && tsa_name && !ts_check_signer_name(tsa_name, signer)) {
        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_NAME_MISMATCH);
        goto err;
    }
    if ((flags & TS_VFY_TSA_NAME)
        && !ts_check_signer_name(ctx->tsa_name, signer)) {
        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_UNTRUSTED);
        goto err;
    }
    ret = 1;

 err:
    X509_free(signer);
    X509_ALGOR_free(md_alg);
    OPENSSL_free(imprint);
    return ret;
}

#endif

void Verify_timestamp_request(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    C_BLOB Param2;
    Param2.fromParamAtIndex(pParams, 2);
    
    CUTF8String _capath, _cafile, _castore, _untrusted;
    char *capath = NULL, *cafile = NULL, *castore = NULL, *untrusted = NULL;
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    int success = 0;
    
    if(options) {
                
        if(ob_get_posix_path(options, L"capath", &_capath)) {
            capath = (char *)_capath.c_str();
        }
        
        if(ob_get_posix_path(options, L"cafile", &_cafile)) {
            cafile = (char *)_cafile.c_str();
        }
        
        /* not used */
        if(ob_get_s(options, L"castore", &_castore)) {
            castore = (char *)_castore.c_str();
        }
        
        if(ob_get_posix_path(options, L"untrusted", &_untrusted)) {
            untrusted = (char *)_untrusted.c_str();
        }
    }
    
    X509_VERIFY_PARAM *vpm = NULL;
    
    if ((vpm = X509_VERIFY_PARAM_new())) {
        
        BIO *bio_Param1 = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());
        BIO *bio_Param2 = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
                
        int ret = 0;
        
        TS_VERIFY_CTX *verify_ctx = NULL;
        
        TS_RESP *response = NULL;
        BIO *bio_response = NULL;
        
        TS_REQ *query = NULL;
        BIO *bio_query = NULL;
        
#if USE_STATIC_OPENSSL_FONCTION_FOR_TRACE
        PKCS7 *pkcs7_token = NULL;
        TS_TST_INFO *tst_info = NULL;
#endif
        
        if ((response = d2i_TS_RESP_bio(bio_Param1, NULL)) == NULL)
            goto end;
        
        bio_response = BIO_new(BIO_s_mem());
        
        if(TS_RESP_print_bio(bio_response, response)) {
            char *buf = NULL;
            int len = (int)BIO_get_mem_data(bio_response, &buf);
            if(len){
                CUTF8String u8 = CUTF8String((const uint8_t *)buf, len);
                ob_set_s(returnValue, L"tsr", (const char *)u8.c_str());
            }
        }
        
        BIO_free(bio_response);
        
        if ((query = d2i_TS_REQ_bio(bio_Param2, NULL)) == NULL)
            goto end;
        
        bio_query = BIO_new(BIO_s_mem());
        if(TS_REQ_print_bio(bio_query, query)) {
            char *buf = NULL;
            int len = (int)BIO_get_mem_data(bio_query, &buf);
            if(len){
                CUTF8String u8 = CUTF8String((const uint8_t *)buf, len);
                ob_set_s(returnValue, L"tsq", (const char *)u8.c_str());
            }
        }
        
        BIO_free(bio_query);
        
        if ((verify_ctx = create_verify_ctx(query,
                                            capath,
                                            cafile,
                                            castore,
                                            untrusted,
                                            vpm)) == NULL) {
            goto end;
        
        }
            
#if USE_STATIC_OPENSSL_FONCTION_FOR_TRACE
      
        tst_info = response->tst_info;
        pkcs7_token = response->token;
        
        if (ts_check_status_info(response){
                if(int_ts_RESP_verify_token(verify_ctx, pkcs7_token, tst_info)) {
                
                    ret = true;
                    
            }
        }
#else
            ret = TS_RESP_verify_response(verify_ctx, response);
#endif
            TS_VERIFY_CTX_free(verify_ctx);

        end:
        
        if(ret) {
            success = true;
        }
        
        TS_REQ_free(query);
        TS_RESP_free(response);
        
        X509_VERIFY_PARAM_free(vpm);
    }
    
    ob_set_b(returnValue, L"success", success);
    
    PA_ReturnObject(params, returnValue);
}
