/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Timestamp.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Timestamp
 #	author : miyako
 #	2020/03/10
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Timestamp.h"

#pragma mark -

void OnStartup() {
    OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \
                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                       
			// --- Timestamp
            
			case 1 :
				Create_timestamp_query(params);
				break;
			case 2 :
				Verify_timestamp_request(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void CC_EVP(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md) {
    
    unsigned int mdlen = mlen;
    EVP_MD_CTX* c = EVP_MD_CTX_new();
    EVP_MD_CTX_reset(c);
    EVP_DigestInit(c, evp);
    EVP_DigestUpdate(c, data, len);
    EVP_DigestFinal(c, md, &mdlen);
    EVP_MD_CTX_free(c);
}

void *app_malloc(int sz, const char *what) {
    
    void *vp = OPENSSL_malloc(sz);
    
    return vp;
}

ASN1_INTEGER *create_nonce(int bits) {
    
    unsigned char buf[20];
    ASN1_INTEGER *nonce = NULL;
    int len = (bits - 1) / 8 + 1;
    int i;

    if (len > (int)sizeof(buf))
        goto err;
    if (RAND_bytes(buf, len) <= 0)
        goto err;

    /* Find the first non-zero byte and creating ASN1_INTEGER object. */
    for (i = 0; i < len && !buf[i]; ++i)
        continue;
    if ((nonce = ASN1_INTEGER_new()) == NULL)
        goto err;
    OPENSSL_free(nonce->data);
    nonce->length = len - i;
    nonce->data = (unsigned char *)app_malloc(nonce->length + 1, "nonce buffer");
    memcpy(nonce->data, buf + i, nonce->length);
    return nonce;

 err:

    ASN1_INTEGER_free(nonce);
    return NULL;
}

ASN1_OBJECT *txt2obj(const char *oid) {
    
    ASN1_OBJECT *oid_obj = OBJ_txt2obj(oid, 0);

    return oid_obj;
}

void CC_SHA(const void *data, uint32_t len, const EVP_MD *evp, unsigned int hashlen, unsigned char *md) {
    
    CC_EVP(evp, hashlen, data, len, md);
}

void CC_HASH(unsigned int hashlen,
             void (*CC)(const void *data,
                        uint32_t len,
                        const EVP_MD *evp,
                        unsigned int hashlen,
                        unsigned char *md),
             const EVP_MD *evp,
             C_BLOB &Param1,
             C_BLOB &returnValue) {

    uint8_t *buf = (uint8_t *)calloc(hashlen, sizeof(uint8_t));
    
    CC((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), evp, hashlen, buf);

    returnValue.setBytes((const uint8_t *)buf, hashlen);
    
    free(buf);
}

#pragma mark -

void Create_timestamp_query(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);

    /*
     defaults:
     format: asn1
     hash: sha512
     cert: 1
     no_nonce: 1
     policy: NULL
     */
    
    timestamp_query_hash_type_t hash_type = timestamp_query_hash_type_sha512;
    timestamp_export_format_t export_format = timestamp_export_format_asn1;
    
    int cert = 1;
    int no_nonce = 1;
    char *policy = NULL;
    
    CUTF8String policyOid;
    
    if(options) {
		unsigned int i = ob_get_n(options, L"format");
        export_format = (timestamp_export_format_t)i;
        
        if(ob_is_defined(options, L"no_nonce")) {
            no_nonce = ob_get_b(options, L"no_nonce");
        }
        
        if(ob_is_defined(options, L"cert")) {
            cert = ob_get_b(options, L"cert");
        }
        
        if(ob_is_defined(options, L"hash")) {
			unsigned int i = ob_get_n(options, L"hash");
            hash_type = (timestamp_query_hash_type_t)i;
        }
        
        if(ob_is_defined(options, L"policy")) {
            ob_get_s(options, L"policy", &policyOid);
            policy = (char *)policyOid.c_str();
        }
 
    }
    
    C_BLOB returnValue;
    
    BIO *bio_Param1 = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());
    
    if(bio_Param1){
        
        const EVP_MD *md = NULL;
        
        switch (hash_type) {
            case timestamp_query_hash_type_sha1:
                md = EVP_sha1();
                CC_HASH(20, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha224:
                md = EVP_sha224();
                CC_HASH(28, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha256:
                md = EVP_sha256();
                CC_HASH(32, CC_SHA, md, Param1, returnValue);
                break;
                
            case timestamp_query_hash_type_sha384:
                md = EVP_sha384();
                CC_HASH(48, CC_SHA, md, Param1, returnValue);
                break;
                
            default:
                md = EVP_sha512();
                CC_HASH(64, CC_SHA, md, Param1, returnValue);
                break;
        }
        
        int ret = 0;
        
        ASN1_INTEGER *nonce_asn1 = NULL;
        X509_ALGOR *algo = NULL;
        TS_MSG_IMPRINT *msg_imprint = NULL;
        TS_REQ *ts_req = NULL;
        ASN1_OBJECT *policy_obj = NULL;
        
        if ((ts_req = TS_REQ_new()) == NULL)
            goto err;
        
        if (!TS_REQ_set_version(ts_req, 1))
            goto err;
        
        if ((msg_imprint = TS_MSG_IMPRINT_new()) == NULL)
            goto err;
        
        if ((algo = X509_ALGOR_new()) == NULL)
            goto err;
        
        if ((algo->algorithm = OBJ_nid2obj(EVP_MD_type(md))) == NULL)
            goto err;
        
        if ((algo->parameter = ASN1_TYPE_new()) == NULL)
            goto err;
        
        algo->parameter->type = V_ASN1_NULL;
        
        if (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo))
            goto err;
        
        if (!TS_MSG_IMPRINT_set_msg(msg_imprint,
                                    (unsigned char *)returnValue.getBytesPtr(),
                                    (int)returnValue.getBytesLength()))
            goto err;
        
        if (!TS_REQ_set_msg_imprint(ts_req, msg_imprint))
            goto err;
                
        if (policy && (policy_obj = txt2obj((const char *)policy)) == NULL)
            goto err;
        
        if (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj))
            goto err;
        
        if (!no_nonce && (nonce_asn1 = create_nonce(NONCE_LENGTH)) == NULL)
            goto err;
        
        if (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1))
            goto err;
        
        if (!TS_REQ_set_cert_req(ts_req, cert))
            goto err;
        
        ret = 1;
        
        err:
        
        if (!ret) {
            TS_REQ_free(ts_req);
            ts_req = NULL;
        }
        
        TS_MSG_IMPRINT_free(msg_imprint);
        X509_ALGOR_free(algo);
        ASN1_OBJECT_free(policy_obj);
        ASN1_INTEGER_free(nonce_asn1);
        
        TS_REQ *query = ts_req;
        
        if (query) {
            
            BIO *bio_returnValue = BIO_new(BIO_s_mem());
            
            if(bio_returnValue) {
                int exported = 0;
                switch (export_format) {
                    case timestamp_export_format_asn1:
                        if(i2d_TS_REQ_bio(bio_returnValue, query)){
                            exported = 1;
                        }
                        break;
                    default:
                        if(TS_REQ_print_bio(bio_returnValue, query)){
                            exported = 1;
                        }
                        break;
                }
                if(exported) {
                    char *buf = NULL;
                    int len = (int)BIO_get_mem_data(bio_returnValue, &buf);
                    
                    if(len){
                        returnValue.setBytes((const uint8_t *)buf, len);
                        returnValue.setReturn(pResult);
                    }
                    
                }
                BIO_free(bio_returnValue);
            }
            TS_REQ_free(query);
        }
        BIO_free(bio_Param1);
    }

}

#pragma mark -

int verify_cb(int ok, X509_STORE_CTX *ctx) {
    
    return ok;
}

/* Reads a PKCS7 token and adds default 'granted' status info to it. */
TS_RESP *read_PKCS7(BIO *in_bio) {
    
    int ret = 0;
    PKCS7 *token = NULL;
    TS_TST_INFO *tst_info = NULL;
    TS_RESP *resp = NULL;
    TS_STATUS_INFO *si = NULL;

    if ((token = d2i_PKCS7_bio(in_bio, NULL)) == NULL)
        goto end;
    if ((tst_info = PKCS7_to_TS_TST_INFO(token)) == NULL)
        goto end;
    if ((resp = TS_RESP_new()) == NULL)
        goto end;
    if ((si = TS_STATUS_INFO_new()) == NULL)
        goto end;
    if (!TS_STATUS_INFO_set_status(si, TS_STATUS_GRANTED))
        goto end;
    if (!TS_RESP_set_status_info(resp, si))
        goto end;
    TS_RESP_set_tst_info(resp, token, tst_info);
    token = NULL;               /* Ownership is lost. */
    tst_info = NULL;            /* Ownership is lost. */
    ret = 1;

 end:
    PKCS7_free(token);
    TS_TST_INFO_free(tst_info);
    if (!ret) {
        TS_RESP_free(resp);
        resp = NULL;
    }
    TS_STATUS_INFO_free(si);
    return resp;
}

X509_STORE *create_cert_store(const char *CApath, const char *CAfile,
                                     const char *CAstore, X509_VERIFY_PARAM *vpm) {
    
    X509_STORE *cert_ctx = NULL;
    X509_LOOKUP *lookup = NULL;

    cert_ctx = X509_STORE_new();
    X509_STORE_set_verify_cb(cert_ctx, verify_cb);
    if (CApath != NULL) {
        lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());
        if (lookup == NULL) {

            goto err;
        }
        if (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM)) {

            goto err;
        }
    }

    if (CAfile != NULL) {
        lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());
        if (lookup == NULL) {

            goto err;
        }
        if (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM)) {

            goto err;
        }
    }

    /*
     if (CAstore != NULL) {
         lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_store());
         if (lookup == NULL) {

             goto err;
         }
         if (!X509_LOOKUP_load_store(lookup, CAstore)) {

             goto err;
         }
     }
     */

    if (vpm != NULL)
        X509_STORE_set1_param(cert_ctx, vpm);

    return cert_ctx;

 err:
    X509_STORE_free(cert_ctx);
    return NULL;
}

TS_VERIFY_CTX *create_verify_ctx(TS_REQ *query,
                                 const char *CApath,
                                 const char *CAfile,
                                 const char *CAstore,
                                 const char *untrusted,
                                 X509_VERIFY_PARAM *vpm) {
    
    TS_VERIFY_CTX *ctx = NULL;
    
    int ret = 0;
    int f = 0;
    
    if (query) {
        if ((ctx = TS_REQ_to_TS_VERIFY_CTX(query, NULL)) == NULL)
            goto err;
    } else {
        return NULL;
    }
    
    /* Add the signature verification flag and arguments. */
    TS_VERIFY_CTX_add_flags(ctx, f | TS_VFY_SIGNATURE);
    
    /* Initialising the X509_STORE object. */
    if (TS_VERIFY_CTX_set_store(ctx,
                                create_cert_store(CApath, CAfile, CAstore, vpm))
        == NULL)
        goto err;
    
    /* Loading untrusted certificates. */
    if (untrusted
        && TS_VERIFY_CTS_set_certs(ctx, TS_CONF_load_certs(untrusted)) == NULL)
        goto err;
    
    ret = 1;
    
err:
    if (!ret) {
        TS_VERIFY_CTX_free(ctx);
        ctx = NULL;
    }

    return ctx;
}

bool ob_get_posix_path(PA_ObjectRef options, const wchar_t *key, CUTF8String *value) {
    
    bool status = ob_get_s(options, key, value);
    
    if(status) {
#if VERSIONMAC
        /* hfs to posix */
        C_TEXT t;
        t.setUTF8String(value);
        t.copyPath(value);
#endif
    }
    
    return status;
}

#pragma mark -

void Verify_timestamp_request(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    C_BLOB Param2;
    Param2.fromParamAtIndex(pParams, 2);
    
    CUTF8String _capath, _cafile, _castore, _untrusted;
    char *capath = NULL, *cafile = NULL, *castore = NULL, *untrusted = NULL;
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    int success = 0;
    
    if(options) {
                
        if(ob_get_posix_path(options, L"capath", &_capath)) {
            capath = (char *)_capath.c_str();
        }
        
        if(ob_get_posix_path(options, L"cafile", &_cafile)) {
            cafile = (char *)_cafile.c_str();
        }
        
        /* not used */
        if(ob_get_s(options, L"castore", &_castore)) {
            castore = (char *)_castore.c_str();
        }
        
        if(ob_get_posix_path(options, L"untrusted", &_untrusted)) {
            untrusted = (char *)_untrusted.c_str();
        }
    }
    
    X509_VERIFY_PARAM *vpm = NULL;
    
    if ((vpm = X509_VERIFY_PARAM_new())) {
        
        BIO *bio_Param1 = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());
        BIO *bio_Param2 = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
                
        int ret = 0;
        
        TS_VERIFY_CTX *verify_ctx = NULL;
        
        TS_RESP *response = NULL;
        BIO *bio_response = NULL;
        
        TS_REQ *query = NULL;
        BIO *bio_query = NULL;
        
        if ((response = d2i_TS_RESP_bio(bio_Param1, NULL)) == NULL)
            goto end;
        
        bio_response = BIO_new(BIO_s_mem());
        if(TS_RESP_print_bio(bio_response, response)) {
            char *buf = NULL;
            int len = (int)BIO_get_mem_data(bio_response, &buf);
            if(len){
                CUTF8String u8 = CUTF8String((const uint8_t *)buf, len);
                ob_set_s(returnValue, L"tsr", (const char *)u8.c_str());
            }
        }
        BIO_free(bio_response);
        
         if ((query = d2i_TS_REQ_bio(bio_Param2, NULL)) == NULL)
             goto end;
         
         bio_query = BIO_new(BIO_s_mem());
         if(TS_REQ_print_bio(bio_query, query)) {
             char *buf = NULL;
             int len = (int)BIO_get_mem_data(bio_query, &buf);
             if(len){
                 CUTF8String u8 = CUTF8String((const uint8_t *)buf, len);
                 ob_set_s(returnValue, L"tsq", (const char *)u8.c_str());
             }
         }
        BIO_free(bio_query);
        
        if ((verify_ctx = create_verify_ctx(query,
                                            capath,
                                            cafile,
                                            castore,
                                            untrusted,
                                            vpm)) == NULL)
            goto end;
        
        ret = TS_RESP_verify_response(verify_ctx, response);

        TS_VERIFY_CTX_free(verify_ctx);
        
        end:
        
        if(ret) {
            success = true;
        }
        
        TS_REQ_free(query);
        TS_RESP_free(response);
        
        X509_VERIFY_PARAM_free(vpm);
    }
    
    ob_set_b(returnValue, L"success", success);
    
    PA_ReturnObject(params, returnValue);
}
